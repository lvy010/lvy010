<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>WebGL â€¢ é«˜é…GitHubé¦–é¡µ</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
            overflow: hidden;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
            background: linear-gradient(135deg, #0d1117 0%, #161b22 50%, #21262d 100%);
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        .header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 2rem 3rem;
            color: #fff;
            pointer-events: none;
            z-index: 10;
            backdrop-filter: blur(10px);
            background: rgba(13, 17, 23, 0.3);
        }
        
        .header h1 {
            font-size: 3rem;
            margin: 0 0 0.5em;
            font-weight: 700;
            background: linear-gradient(135deg, #58a6ff, #f85149, #7c3aed);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 20px rgba(88, 166, 255, 0.5); }
            to { text-shadow: 0 0 30px rgba(88, 166, 255, 0.8), 0 0 40px rgba(248, 81, 73, 0.3); }
        }
        
        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            opacity: 0.9;
            color: #f0f6fc;
        }
        
        .btn {
            display: inline-block;
            padding: 1rem 2rem;
            background: linear-gradient(135deg, #238636, #2ea043);
            color: #fff;
            border-radius: 12px;
            text-decoration: none;
            pointer-events: auto;
            font-weight: 600;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(35, 134, 54, 0.3);
            border: 1px solid rgba(46, 160, 67, 0.5);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(35, 134, 54, 0.4);
            background: linear-gradient(135deg, #2ea043, #238636);
        }
        
        .stats {
            position: absolute;
            bottom: 2rem;
            left: 3rem;
            color: #8b949e;
            pointer-events: none;
            font-size: 0.9rem;
        }
        
        .controls {
            position: absolute;
            bottom: 2rem;
            right: 3rem;
            color: #8b949e;
            pointer-events: none;
            font-size: 0.8rem;
            text-align: right;
        }
        
        .settings-panel {
            position: absolute;
            top: 2rem;
            right: 2rem;
            background: rgba(13, 17, 23, 0.9);
            border: 1px solid rgba(88, 166, 255, 0.3);
            border-radius: 12px;
            padding: 1rem;
            color: #f0f6fc;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 20;
            min-width: 200px;
        }
        
        .settings-panel.open {
            transform: translateX(0);
        }
        
        .settings-toggle {
            position: absolute;
            top: 2rem;
            right: 2rem;
            background: rgba(88, 166, 255, 0.2);
            border: 1px solid rgba(88, 166, 255, 0.5);
            color: #58a6ff;
            padding: 0.5rem;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            z-index: 21;
            pointer-events: auto;
        }
        
        .settings-toggle:hover {
            background: rgba(88, 166, 255, 0.3);
            transform: rotate(90deg);
        }
        
        .slider-container {
            margin: 0.5rem 0;
        }
        
        .slider {
            width: 100%;
            height: 4px;
            background: rgba(88, 166, 255, 0.3);
            border-radius: 2px;
            outline: none;
            pointer-events: auto;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: #58a6ff;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .performance-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .performance-good { background: #2ea043; }
        .performance-medium { background: #fb8500; }
        .performance-poor { background: #f85149; }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #58a6ff;
            font-size: 1.2rem;
            z-index: 5;
        }
        
        @media (max-width: 768px) {
            .header {
                padding: 1rem 1.5rem;
            }
            .header h1 {
                font-size: 2rem;
            }
            .stats, .controls {
                bottom: 1rem;
                left: 1.5rem;
                right: 1.5rem;
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">åˆå§‹åŒ–WebGL...</div>
    <canvas id="canvas"></canvas>
    
    <header class="header">
        <h1>Build software better, together.</h1>
        <p class="subtitle">GitHubæ˜¯å…¨çƒæœ€å¤§çš„ä»£ç æ‰˜ç®¡å¹³å°ï¼Œè¿æ¥æ•°ç™¾ä¸‡å¼€å‘è€…</p>
        <a class="btn" href="https://github.com/join" target="_blank">åŠ å…¥GitHub</a>
    </header>
    
    <div class="stats" id="stats">
        ç²’å­æ•°é‡: <span id="particleCount">0</span> | FPS: <span id="fps">0</span>
    </div>
    
    <div class="controls">
        <div>ğŸ–±ï¸ æ‹–æ‹½æ—‹è½¬ | ğŸ”„ æ»šè½®ç¼©æ”¾</div>
        <div>WebGLé«˜æ€§èƒ½æ¸²æŸ“</div>
    </div>
    
    <div class="settings-toggle" onclick="toggleSettings()">âš™ï¸</div>
    <div class="settings-panel" id="settingsPanel">
        <h4 style="margin: 0 0 1rem 0; color: #58a6ff;">æ¸²æŸ“è®¾ç½®</h4>
        
        <div class="slider-container">
            <label>ç²’å­æ•°é‡: <span id="particleCountLabel">1200</span></label>
            <input type="range" class="slider" id="particleSlider" 
                   min="300" max="2000" value="1200" 
                   oninput="updateParticleCount(this.value)">
        </div>
        
        <div class="slider-container">
            <label>åŠ¨ç”»é€Ÿåº¦: <span id="speedLabel">1.0x</span></label>
            <input type="range" class="slider" id="speedSlider" 
                   min="0.1" max="3.0" step="0.1" value="1.0" 
                   oninput="updateAnimationSpeed(this.value)">
        </div>
        
        <div class="slider-container">
            <label>ç²’å­å¤§å°: <span id="sizeLabel">1.0x</span></label>
            <input type="range" class="slider" id="sizeSlider" 
                   min="0.5" max="2.0" step="0.1" value="1.0" 
                   oninput="updateParticleSize(this.value)">
        </div>
        
        <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(88, 166, 255, 0.3);">
            <div>æ€§èƒ½çŠ¶æ€: <span class="performance-indicator" id="perfIndicator"></span><span id="perfStatus">è‰¯å¥½</span></div>
            <div style="margin-top: 0.5rem;">
                <button onclick="resetSettings()" style="background: rgba(88, 166, 255, 0.2); border: 1px solid rgba(88, 166, 255, 0.5); color: #58a6ff; padding: 0.3rem 0.8rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">é‡ç½®è®¾ç½®</button>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        const loading = document.getElementById('loading');
        
        // å¯è°ƒèŠ‚å‚æ•°
        let animationSpeed = 1.0;
        let particleSizeMultiplier = 1.0;
        let currentPerformance = 'good';
        
        if (!gl) {
            loading.textContent = 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒWebGL';
            throw new Error('WebGL not supported');
        }
        
        // å·¥å…·å‡½æ•° - å¢å¼ºé”™è¯¯å¤„ç†
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const error = gl.getShaderInfoLog(shader);
                console.error('ç€è‰²å™¨ç¼–è¯‘é”™è¯¯:', error);
                console.error('ç€è‰²å™¨æºç :', source);
                
                // æ˜¾ç¤ºè¯¦ç»†é”™è¯¯ä¿¡æ¯
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    background: rgba(248, 81, 73, 0.9); color: white; padding: 20px;
                    border-radius: 8px; font-family: monospace; font-size: 12px;
                    max-width: 80%; max-height: 60%; overflow: auto; z-index: 1000;
                `;
                errorDiv.innerHTML = `
                    <h3>WebGL ç€è‰²å™¨ç¼–è¯‘å¤±è´¥</h3>
                    <p><strong>é”™è¯¯ä¿¡æ¯:</strong></p>
                    <pre>${error}</pre>
                    <button onclick="this.parentElement.remove(); initFallback();" 
                            style="margin-top: 10px; padding: 5px 10px; background: #fff; 
                                   color: #000; border: none; border-radius: 4px; cursor: pointer;">
                        ä½¿ç”¨é™çº§ç‰ˆæœ¬
                    </button>
                `;
                document.body.appendChild(errorDiv);
                
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('ç¨‹åºé“¾æ¥é”™è¯¯:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }
        
        // çŸ©é˜µè¿ç®—
        function mat4() {
            return new Float32Array(16);
        }
        
        function mat4Identity(out) {
            out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
            out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
            return out;
        }
        
        function mat4Perspective(out, fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            const nf = 1 / (near - far);
            
            out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = (far + near) * nf; out[11] = -1;
            out[12] = 0; out[13] = 0; out[14] = (2 * far * near) * nf; out[15] = 0;
            return out;
        }
        
        function mat4RotateX(out, rad) {
            const s = Math.sin(rad);
            const c = Math.cos(rad);
            
            out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = c; out[6] = s; out[7] = 0;
            out[8] = 0; out[9] = -s; out[10] = c; out[11] = 0;
            out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
            return out;
        }
        
        function mat4RotateY(out, rad) {
            const s = Math.sin(rad);
            const c = Math.cos(rad);
            
            out[0] = c; out[1] = 0; out[2] = -s; out[3] = 0;
            out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
            out[8] = s; out[9] = 0; out[10] = c; out[11] = 0;
            out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
            return out;
        }
        
        function mat4Multiply(out, a, b) {
            const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
            
            let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
            out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            
            b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
            out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            
            b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
            out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            
            b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
            out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            return out;
        }
        
        function mat4Scale(out, v) {
            out[0] *= v; out[1] *= v; out[2] *= v; out[3] *= v;
            out[4] *= v; out[5] *= v; out[6] *= v; out[7] *= v;
            out[8] *= v; out[9] *= v; out[10] *= v; out[11] *= v;
            out[12] *= v; out[13] *= v; out[14] *= v; out[15] *= v;
            return out;
        }
        
        // ç€è‰²å™¨æºç  - ä¿®å¤å…¼å®¹æ€§é—®é¢˜
        const vertexShaderSource = `
            precision highp float;
            
            attribute vec3 aPosition;
            attribute float aSize;
            attribute vec3 aColor;
            attribute float aAlpha;
            
            uniform mat4 uProjectionMatrix;
            uniform mat4 uModelViewMatrix;
            uniform float uTime;
            uniform float uZoom;
            
            varying vec3 vColor;
            varying float vAlpha;
            
            void main() {
                // å‘¼å¸æ•ˆæœ
                float breathe = 1.0 + 0.3 * sin(uTime * 2.0 + aPosition.x * 5.0 + aPosition.y * 3.0);
                
                // æ—‹è½¬åŠ¨ç”»
                float rotSpeed = 0.5;
                vec3 pos = aPosition;
                float angle = uTime * rotSpeed + length(aPosition) * 2.0;
                
                // è½¨é“è¿åŠ¨
                float cosAngle = cos(angle);
                float sinAngle = sin(angle);
                pos.x = aPosition.x * cosAngle - aPosition.z * sinAngle;
                pos.z = aPosition.x * sinAngle + aPosition.z * cosAngle;
                
                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = aSize * breathe * uZoom;
                
                vColor = aColor;
                vAlpha = aAlpha * breathe * 0.8;
            }
        `;
        
        const fragmentShaderSource = `
            precision mediump float;
            
            uniform float uTime;
            
            varying vec3 vColor;
            varying float vAlpha;
            
            void main() {
                vec2 uv = gl_PointCoord * 2.0 - 1.0;
                float dist = length(uv);
                
                if (dist > 1.0) discard;
                
                // éœ“è™¹å…‰æ•ˆ
                float glow = 1.0 - dist;
                glow = pow(glow, 2.0);
                
                // åŠ¨æ€é¢œè‰²å˜åŒ–
                vec3 color = vColor;
                vec2 fragCoord = gl_FragCoord.xy * 0.01;
                color += 0.3 * vec3(
                    sin(uTime * 3.0 + fragCoord.x),
                    sin(uTime * 3.5 + fragCoord.y),
                    sin(uTime * 4.0 + fragCoord.x + fragCoord.y)
                );
                
                // è¾¹ç¼˜å…‰æ™•
                float edge = smoothstep(0.8, 0.2, dist);
                color += vec3(edge * 0.5);
                
                // è„‰å†²æ•ˆæœ
                float pulse = 0.8 + 0.2 * sin(uTime * 5.0);
                
                gl_FragColor = vec4(color * glow * pulse, vAlpha * glow);
            }
        `;
        
        // åˆå§‹åŒ–WebGL
        let program, projectionMatrix, modelViewMatrix;
        let particleCount = 1200;
        let positions, sizes, colors, alphas;
        let positionBuffer, sizeBuffer, colorBuffer, alphaBuffer;
        
        function initWebGL() {
            // åˆ›å»ºç€è‰²å™¨
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            
            if (!vertexShader || !fragmentShader) {
                loading.textContent = 'ç€è‰²å™¨åˆ›å»ºå¤±è´¥';
                return false;
            }
            
            // åˆ›å»ºç¨‹åº
            program = createProgram(gl, vertexShader, fragmentShader);
            if (!program) {
                loading.textContent = 'ç¨‹åºåˆ›å»ºå¤±è´¥';
                return false;
            }
            
            // è·å–å±æ€§å’Œuniformä½ç½®
            program.aPosition = gl.getAttribLocation(program, 'aPosition');
            program.aSize = gl.getAttribLocation(program, 'aSize');
            program.aColor = gl.getAttribLocation(program, 'aColor');
            program.aAlpha = gl.getAttribLocation(program, 'aAlpha');
            
            program.uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');
            program.uModelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
            program.uTime = gl.getUniformLocation(program, 'uTime');
            program.uZoom = gl.getUniformLocation(program, 'uZoom');
            
            // ç”Ÿæˆç²’å­æ•°æ®
            generateParticles();
            
            // åˆ›å»ºç¼“å†²åŒº
            createBuffers();
            
            // è®¾ç½®WebGLçŠ¶æ€
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.clearColor(0.05, 0.07, 0.1, 1.0);
            
            return true;
        }
        
        function generateParticles() {
            positions = new Float32Array(particleCount * 3);
            sizes = new Float32Array(particleCount);
            colors = new Float32Array(particleCount * 3);
            alphas = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // åˆ›å»ºèºæ—‹æ˜Ÿè½¨
                const t = (i / particleCount) * Math.PI * 2 * 8; // 8åœˆèºæ—‹
                const r = 1.5 + Math.sin(t * 2) * 0.6 + Math.random() * 0.4;
                const height = (i / particleCount - 0.5) * 2;
                
                positions[i3] = Math.cos(t) * r;
                positions[i3 + 1] = Math.sin(t) * r + height * 0.3;
                positions[i3 + 2] = height;
                
                // ç²’å­å¤§å°
                sizes[i] = 3 + Math.random() * 8;
                
                // æ¸å˜é¢œè‰² - ä»è“åˆ°ç´«åˆ°çº¢
                const colorPhase = (i / particleCount) * 3;
                if (colorPhase < 1) {
                    colors[i3] = 0.3 + colorPhase * 0.4; // R
                    colors[i3 + 1] = 0.6 + colorPhase * 0.2; // G
                    colors[i3 + 2] = 1.0; // B
                } else if (colorPhase < 2) {
                    const phase = colorPhase - 1;
                    colors[i3] = 0.7 + phase * 0.3; // R
                    colors[i3 + 1] = 0.8 - phase * 0.5; // G
                    colors[i3 + 2] = 1.0 - phase * 0.5; // B
                } else {
                    const phase = colorPhase - 2;
                    colors[i3] = 1.0; // R
                    colors[i3 + 1] = 0.3 + phase * 0.2; // G
                    colors[i3 + 2] = 0.5 - phase * 0.3; // B
                }
                
                // é€æ˜åº¦
                alphas[i] = 0.6 + Math.random() * 0.4;
            }
            
            document.getElementById('particleCount').textContent = particleCount;
        }
        
        function createBuffers() {
            // ä½ç½®ç¼“å†²åŒº
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            
            // å¤§å°ç¼“å†²åŒº
            sizeBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);
            
            // é¢œè‰²ç¼“å†²åŒº
            colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
            
            // é€æ˜åº¦ç¼“å†²åŒº
            alphaBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, alphaBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, alphas, gl.STATIC_DRAW);
        }
        
        // äº¤äº’æ§åˆ¶
        let mouseX = 0, mouseY = 0;
        let rotationX = 0.2, rotationY = 0;
        let zoom = 1.0;
        let isDragging = false;
        let lastMouseX = 0, lastMouseY = 0;
        
        function setupInteraction() {
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });
            
            canvas.addEventListener('mousemove', (e) => {
                mouseX = (e.clientX / canvas.clientWidth) * 2 - 1;
                mouseY = -((e.clientY / canvas.clientHeight) * 2 - 1);
                
                if (isDragging) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;
                    
                    rotationY += deltaX * 0.01;
                    rotationX += deltaY * 0.01;
                    
                    // é™åˆ¶Xè½´æ—‹è½¬
                    rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX));
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY * 0.001;
                zoom *= (1 + delta);
                zoom = Math.max(0.1, Math.min(3.0, zoom));
            });
            
            // è§¦æ‘¸æ”¯æŒ
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    isDragging = true;
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                }
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (isDragging && e.touches.length === 1) {
                    const deltaX = e.touches[0].clientX - lastMouseX;
                    const deltaY = e.touches[0].clientY - lastMouseY;
                    
                    rotationY += deltaX * 0.01;
                    rotationX += deltaY * 0.01;
                    
                    rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX));
                    
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                }
            });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                isDragging = false;
            });
        }
        
        // çª—å£å¤§å°è°ƒæ•´
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            // æ›´æ–°æŠ•å½±çŸ©é˜µ
            projectionMatrix = mat4();
            mat4Perspective(projectionMatrix, Math.PI / 4, width / height, 0.1, 100.0);
        }
        
        // æ¸²æŸ“
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;
        
        function render(currentTime) {
            currentTime *= 0.001; // è½¬æ¢ä¸ºç§’
            
            // è®¡ç®—FPS
            frameCount++;
            if (currentTime - lastTime >= 1.0) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                document.getElementById('fps').textContent = fps;
                updatePerformanceIndicator(fps);
            }
            
            // æ¸…å±
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // ä½¿ç”¨ç¨‹åº
            gl.useProgram(program);
            
            // è®¾ç½®çŸ©é˜µ
            modelViewMatrix = mat4();
            mat4Identity(modelViewMatrix);
            
            // åº”ç”¨å˜æ¢
            const tempMatrix = mat4();
            mat4RotateX(tempMatrix, rotationX);
            mat4Multiply(modelViewMatrix, modelViewMatrix, tempMatrix);
            
            mat4RotateY(tempMatrix, rotationY);
            mat4Multiply(modelViewMatrix, modelViewMatrix, tempMatrix);
            
            mat4Scale(modelViewMatrix, zoom);
            
            // ä¼ é€’uniform
            gl.uniformMatrix4fv(program.uProjectionMatrix, false, projectionMatrix);
            gl.uniformMatrix4fv(program.uModelViewMatrix, false, modelViewMatrix);
            gl.uniform1f(program.uTime, currentTime * animationSpeed);
            gl.uniform1f(program.uZoom, zoom * particleSizeMultiplier);
            
            // ç»‘å®šå±æ€§
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(program.aPosition);
            gl.vertexAttribPointer(program.aPosition, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
            gl.enableVertexAttribArray(program.aSize);
            gl.vertexAttribPointer(program.aSize, 1, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.enableVertexAttribArray(program.aColor);
            gl.vertexAttribPointer(program.aColor, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, alphaBuffer);
            gl.enableVertexAttribArray(program.aAlpha);
            gl.vertexAttribPointer(program.aAlpha, 1, gl.FLOAT, false, 0, 0);
            
            // ç»˜åˆ¶ç²’å­
            gl.drawArrays(gl.POINTS, 0, particleCount);
            
            requestAnimationFrame(render);
        }
        
        // åˆå§‹åŒ–
        function init() {
            if (!initWebGL()) {
                return;
            }
            
            setupInteraction();
            resizeCanvas();
            
            window.addEventListener('resize', resizeCanvas);
            
            // éšè—åŠ è½½æç¤º
            loading.style.display = 'none';
            
            // åˆå§‹åŒ–æ€§èƒ½æŒ‡ç¤ºå™¨
            updatePerformanceIndicator(60);
            
            // å¼€å§‹æ€§èƒ½ç›‘æ§
            setTimeout(checkPerformance, 2000);
            
            // å¼€å§‹æ¸²æŸ“
            requestAnimationFrame(render);
        }
        
        // CSSåŠ¨ç”»é™çº§æ–¹æ¡ˆ
        function initFallback() {
            console.log('å¯ç”¨CSSé™çº§æ–¹æ¡ˆ');
            canvas.style.display = 'none';
            loading.style.display = 'none';
            
            // åˆ›å»ºCSSåŠ¨ç”»èƒŒæ™¯
            const fallbackDiv = document.createElement('div');
            fallbackDiv.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
                overflow: hidden; z-index: 1;
            `;
            
            // åˆ›å»ºåŠ¨ç”»ç²’å­
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                const size = Math.random() * 4 + 2;
                const x = Math.random() * 100;
                const y = Math.random() * 100;
                const duration = Math.random() * 20 + 10;
                const delay = Math.random() * 5;
                
                particle.style.cssText = `
                    position: absolute; width: ${size}px; height: ${size}px;
                    background: radial-gradient(circle, #58a6ff, #7c3aed);
                    border-radius: 50%; left: ${x}%; top: ${y}%;
                    animation: float ${duration}s ${delay}s infinite linear;
                    opacity: ${Math.random() * 0.8 + 0.2};
                    box-shadow: 0 0 ${size * 2}px rgba(88, 166, 255, 0.5);
                `;
                fallbackDiv.appendChild(particle);
            }
            
            document.body.insertBefore(fallbackDiv, document.body.firstChild);
            
            // æ·»åŠ CSSåŠ¨ç”»å…³é”®å¸§
            const style = document.createElement('style');
            style.textContent = `
                @keyframes float {
                    0% { transform: translateY(100vh) rotate(0deg); }
                    100% { transform: translateY(-100px) rotate(360deg); }
                }
                @keyframes pulse {
                    0%, 100% { opacity: 0.5; transform: scale(1); }
                    50% { opacity: 1; transform: scale(1.2); }
                }
            `;
            document.head.appendChild(style);
            
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            document.getElementById('particleCount').textContent = '50 (CSS)';
            document.getElementById('fps').textContent = '60 (ä¼°è®¡)';
        }
        
        // æ€§èƒ½ç›‘æ§
        function checkPerformance() {
            const start = performance.now();
            let frameCount = 0;
            
            function measureFrame() {
                frameCount++;
                if (frameCount === 60) {
                    const avgTime = (performance.now() - start) / 60;
                    if (avgTime > 20) { // å¦‚æœå¹³å‡å¸§æ—¶é—´è¶…è¿‡20ms
                        console.warn('æ€§èƒ½è¾ƒä½ï¼Œå»ºè®®é™ä½ç²’å­æ•°é‡');
                        particleCount = Math.max(300, particleCount * 0.5);
                        generateParticles();
                        createBuffers();
                    }
                } else if (frameCount < 60) {
                    requestAnimationFrame(measureFrame);
                }
            }
            requestAnimationFrame(measureFrame);
        }
        
        // è®¾ç½®é¢æ¿æ§åˆ¶å‡½æ•°
        function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            panel.classList.toggle('open');
        }
        
        function updateParticleCount(value) {
            particleCount = parseInt(value);
            document.getElementById('particleCountLabel').textContent = particleCount;
            document.getElementById('particleCount').textContent = particleCount;
            
            // é‡æ–°ç”Ÿæˆç²’å­
            generateParticles();
            createBuffers();
        }
        
        function updateAnimationSpeed(value) {
            animationSpeed = parseFloat(value);
            document.getElementById('speedLabel').textContent = value + 'x';
        }
        
        function updateParticleSize(value) {
            particleSizeMultiplier = parseFloat(value);
            document.getElementById('sizeLabel').textContent = value + 'x';
        }
        
        function resetSettings() {
            // é‡ç½®æ»‘å—å€¼
            document.getElementById('particleSlider').value = 1200;
            document.getElementById('speedSlider').value = 1.0;
            document.getElementById('sizeSlider').value = 1.0;
            
            // é‡ç½®å˜é‡
            updateParticleCount(1200);
            updateAnimationSpeed(1.0);
            updateParticleSize(1.0);
        }
        
        function updatePerformanceIndicator(fps) {
            const indicator = document.getElementById('perfIndicator');
            const status = document.getElementById('perfStatus');
            
            if (fps >= 50) {
                currentPerformance = 'good';
                indicator.className = 'performance-indicator performance-good';
                status.textContent = 'è‰¯å¥½';
            } else if (fps >= 30) {
                currentPerformance = 'medium';
                indicator.className = 'performance-indicator performance-medium';
                status.textContent = 'ä¸€èˆ¬';
            } else {
                currentPerformance = 'poor';
                indicator.className = 'performance-indicator performance-poor';
                status.textContent = 'è¾ƒå·®';
                
                // è‡ªåŠ¨ä¼˜åŒ–
                if (particleCount > 600) {
                    const newCount = Math.max(600, particleCount * 0.8);
                    document.getElementById('particleSlider').value = newCount;
                    updateParticleCount(newCount);
                }
            }
        }
        
        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'r':
                case 'R':
                    resetSettings();
                    break;
                case 's':
                case 'S':
                    toggleSettings();
                    break;
                case ' ':
                    e.preventDefault();
                    animationSpeed = animationSpeed > 0 ? 0 : 1.0;
                    document.getElementById('speedSlider').value = animationSpeed;
                    updateAnimationSpeed(animationSpeed);
                    break;
            }
        });
        
        // å¯åŠ¨åº”ç”¨
        init();
    </script>
</body>
</html>

